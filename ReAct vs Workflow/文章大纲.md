# 《几十行代码替代工作流？ReAct Agent 与 Workflow 的边界探讨》

## 定位

- 技术科普 + 中度实战
    
- 目标读者：用过 LangChain 的开发者，在选型 Agent vs Workflow
    
- 篇幅：6000-8000 字
    
- 重点：deepagents 能力 + 实战思路，n8n 做引子
    

---

## 文章结构

### 开篇：震撼对比（800 字）

**引子：一个真实的自动化场景**

- 销售线索调研：从网站自动提取公司业务信息
    
- n8n 实现：4 阶段工作流
    
    - 阶段 1: 触发 + 首页抓取
        
    - 阶段 2: AI 判断信息完整性 → Switch 分支
        
    - 阶段 3: 抓取 About 页（条件执行）
        
    - 阶段 4: 数据同步 + 通知
        
- n8n 需要配置的东西：HTTP 节点、HTML 解析器、AI 节点、Switch、数据映射
    

**对比：几十行代码的 ReAct Agent**

- 展示核心思路（不贴完整代码）
    
- 关键点：
    
    - 3 个工具：scrape_page, find_about_link, log_insight
        
    - 1 个 prompt：定义工作流逻辑
        
    - LangGraph 的 create_react_agent 搞定
        
- 代码行数对比
    

**抛出核心问题**

- "ReAct Agent 能替代 Workflow 吗？"
    
- "如果能，边界在哪？如果不能，为什么？"
    
- "这篇文章会从 deepagents 的能力出发，探讨这个问题。"
    

---

### 第一部分：deepagents 是什么（1500 字）

**1.1 技术栈定位**

- LangChain = 工具层（模型、工具定义）
    
- LangGraph = 图编排层（状态机、流程控制）
    
- deepagents = Agent 框架层（预设工具集 + ReAct 循环 + Middleware）
    

**1.2 核心能力：不只是简单的 ReAct**

- **规划工具（TodoListMiddleware）**
    
    - `write_todos` / `read_todos`
        
    - Agent 可以自主规划任务列表、跟踪进度
        
    - 适合长时程任务（几十步的推理链）
        
- **文件系统后端（FilesystemMiddleware）**
    
    - 完整的文件操作能力：ls, read_file, write_file, edit_file, glob, grep, execute
        
    - 多种后端实现：
        
        - StateBackend: 临时状态
            
        - FilesystemBackend: 真实磁盘
            
        - StoreBackend: 持久化存储（跨对话）
            
        - CompositeBackend: 混合路由
            
    - 为什么需要文件系统？复杂任务的上下文管理
        
- **子 Agent 委托（SubAgentMiddleware）**
    
    - `task()` 工具：将任务委托给子 agent
        
    - 每个子 agent 有独立的 context、指令、工具集
        
    - 分治策略：大任务拆解成小任务
        
- **其他增强能力**
    
    - SummarizationMiddleware: 上下文超 170k token 时自动总结
        
    - AnthropicPromptCachingMiddleware: 缓存系统提示词降低成本
        
    - HumanInTheLoopMiddleware: 敏感工具需人工审批
        

**1.3 demo 用了什么、没用什么（坦诚说明）**

- demo 用了：LangGraph 原生的 `create_react_agent`
    
- demo 没用：deepagents 的所有 middleware
    
- 为什么？demo 的任务太简单（2-4 次工具调用）
    
- deepagents 的价值在于**长时程复杂任务**
    

**1.4 快速开始（代码片段）**

- 展示 deepagents 的基本用法
    
- 如何创建 agent
    
- 如何添加自定义工具
    
- 如何配置 subagent
    

---

### 第二部分：为什么几十行代码就够了（1800 字）

**2.1 核心思想：Prompt 重新编码业务逻辑**

- n8n 用节点图表达流程
    
- Agent 用自然语言表达流程
    
- 展示 demo 的 SYSTEM_PROMPT：
    

```text
步骤 1: 访问首页（必须调用 scrape_page）步骤 2: 判断信息完整性  - 完整 → 跳到步骤 3  - 缺失 → 查找 About 页面步骤 3: 生成洞察（必须调用 log_insight）
```

- 这就是"用自然语言编程"
    

**2.2 ReAct 循环 vs 节点图**

- **节点图（n8n）**：
    
    - 显式编排：每个节点功能固定，连线预设
        
    - 执行模型：DAG 遍历
        
    - 决策位置：设计时（Switch 节点硬编码）
        
- **ReAct 循环（Agent）**：
    
    - 隐式编排：LLM 根据 prompt 实时决策
        
    - 执行模型：Reason → Act → Observe 循环
        
    - 决策位置：运行时（LLM 每次推理）
        

**2.3 关键代码思路讲解**

- **如何定义工具**
    

```python
from langchain_core.tools import tool@tooldef scrape_page(url: str) -> str:    """抓取网页内容并转为 Markdown"""    # 实现细节：URL 验证、防重复、Firecrawl/BeautifulSoup    ...
```

关键点：

- 工具的 docstring 是 LLM 理解工具的唯一途径
    
- 参数类型提示很重要
    
- 错误处理（返回友好的错误信息给 LLM）
    
- **如何用 Prompt 定义流程**
    
    - 明确的步骤描述
        
    - 严格的约束条件（禁止跳过首页、访问次数限制）
        
    - 清晰的输出格式要求
        
- **如何创建 Agent**
    

```python
from langgraph.prebuilt import create_react_agentagent = create_react_agent(    llm=ChatOpenAI(...),    tools=[scrape_page, find_about_link, log_insight],    prompt=SYSTEM_PROMPT)
```

- **如何执行和监控**
    

```python
for event in agent.stream(    {"messages": [("user", f"请调研这家公司: {website}")]},    config={"recursion_limit": 10},    stream_mode="values"):    # 输出每一步的 Thought 和 Tool Call
```

**2.4 动态决策的边界：真动态 vs 伪动态**

- **真动态**：LLM 根据页面内容自主判断"信息是否完整"
    
- **伪动态**：prompt 规定了"必须判断信息完整性"
    
- demo 是介于两者之间：
    
    - 流程框架是固定的（prompt 规定了步骤）
        
    - 具体决策是动态的（是否爬 About 页）
        
- 完全的动态 Agent：prompt 只说"调研这家公司"，不规定步骤
    

---

### 第三部分：什么时候该用 Agent（1800 字）

**3.1 能替代的场景**

- **业务逻辑复杂但能自然语言描述**
    
    - 例：demo 中的调研流程
        
    - n8n 需要配置 10+ 个节点
        
    - Agent 只需几句话的 prompt
        
- **需要动态决策，难以穷举分支**
    
    - 例：判断"信息是否完整"（没有简单的规则）
        
    - n8n: 需要 AI 节点 + Switch 节点 + 硬编码规则
        
    - Agent: LLM 自然理解语义
        
- **长尾场景多，穷举成本高**
    
    - 例：网站结构千差万别（有的 About 在 /about，有的在 /company/about-us）
        
    - n8n: 需要为每种情况配置分支
        
    - Agent: prompt 一句话覆盖（"查找关于我们页面，可能是 About / Company / Team 等"）
        

**3.2 不该替代的场景**

- **严格顺序要求**
    
    - 例：支付流程（验证 → 扣款 → 记账）
        
    - Agent 可能因 LLM 理解偏差跳过某一步
        
    - 关键系统不允许这种不确定性
        
- **高频低成本任务**
    
    - 成本对比表格：
        

|   |   |   |
|---|---|---|
|任务频率|n8n 成本（每次）|Agent 成本（每次）|
|数据同步（1秒1次）|$0.0001|$0.01-0.05|
|每日报告（1次/天）|$0.001|$0.05-0.2|

- 高频任务用 Agent 成本爆炸
    
- **监管审计要求**
    
    - 需要证明"完全按流程图执行"
        
    - 节点图可导出审计日志
        
    - Agent 的 Thought 链虽可解释，但不够直观
        
- **需要实时性保证**
    
    - n8n 某节点固定 50ms
        
    - Agent 某次 2s 某次 20s（LLM 推理时间不确定）
        

**3.3 决策矩阵（2x2 表格）**

|   |   |   |
|---|---|---|
|维度|高确定性需求|低确定性需求|
|**简单流程**|n8n（例：数据同步）|n8n 或 Agent 都可（例：定时报告）|
|**复杂流程**|n8n + 人工审核（例：订单履约）|**Agent 最优**（例：销售调研）|

**3.4 Token 成本不可控的深层原因**

- ReAct 循环次数不确定
    
- 上下文累积（每次工具返回追加到历史）
    
- LLM 自主决策的随机性
    
- 缓解策略：
    
    - Prompt 优化（指导 Agent"用最少步骤"）
        
    - 递归深度限制（recursion_limit）
        
    - Prompt Caching（deepagents 内置）
        

---

### 第四部分：混合方案 —— 最佳实践（1500 字）

**4.1 核心观点：Agent 和 Workflow 不是替代关系，而是分层协作**

- **Agent 做什么**：
    
    - 高层决策：根据输入判断"这是什么类型的任务"
        
    - 动态路由：调用对应的 workflow
        
    - 处理长尾：workflow 覆盖不到的边缘情况
        
- **Workflow 做什么**：
    
    - 底层执行：保证关键步骤的确定性
        
    - 高频任务：成本可控的重复性工作
        
    - 可审计流程：需要合规证明的场景
        

**4.2 架构示意（文字描述，读者可自己画图）**

```text
用户输入   ↓[Agent: 理解意图 + 规划策略]   ↓判断调用哪个 Workflow   ↓[Workflow A: 确定性执行]  OR  [Workflow B: 确定性执行]   ↓结果返回给 Agent   ↓[Agent: 后处理 + 响应用户]
```

**4.3 具体案例构想**

**案例 1: 智能客服系统**

- **Agent 层**：
    
    - 理解用户意图（退货 / 查询订单 / 投诉）
        
    - 决定调用哪个 workflow
        
    - 处理复杂对话（用户意图不明确时追问）
        
- **Workflow 层**：
    
    - 退货流程 workflow：验证订单 → 生成退货单 → 通知仓库
        
    - 查询订单 workflow：查数据库 → 格式化返回
        
    - 投诉处理 workflow：记录 → 分配客服 → 发送通知
        

**案例 2: 数据分析管道**

- **Agent 层**：
    
    - 理解分析需求（"分析本月销售趋势"）
        
    - 规划分析步骤（需要哪些数据 → 如何聚合 → 用什么图表）
        
    - 使用 deepagents 的 TodoList 工具规划
        
- **Workflow 层**：
    
    - ETL workflow：从数据库提取数据 → 清洗 → 加载到分析库
        
    - 可视化 workflow：生成图表 → 导出 PDF
        
    - 报告发送 workflow：发送邮件 / 飞书通知
        

**4.4 实现建议**

- **将 Workflow 封装为 Agent 的工具**
    

```python
@tooldef run_refund_workflow(order_id: str) -> str:    """执行退货流程"""    result = n8n_client.trigger_workflow("refund", {"order_id": order_id})    return resultagent = create_deep_agent(    tools=[run_refund_workflow, run_query_workflow, ...],    system_prompt="你是智能客服，根据用户意图调用对应流程...")
```

- **Agent 的职责边界**：
    
    - 做决策，不做执行
        
    - 做规划，不做重复劳动
        
    - 做长尾，不做确定性
        

---

### 结尾：给选型者的建议（600 字）

**三个判断标准**

1. **任务复杂度**
    
    - < 5 步固定流程 → n8n
        
    - 5 步且有动态决策 → Agent
        
    - 复杂流程 + 核心步骤需确定性 → 混合方案
        
2. **成本敏感度**
    
    - 高频任务（分钟级） → n8n
        
    - 低频任务（小时/天级） → Agent 可接受
        
    - 需要精确成本预算 → n8n
        
3. **团队技术栈**
    
    - 团队熟悉 LangChain/Python → Agent 开发效率高
        
    - 团队偏好可视化 / 非技术人员需维护 → n8n
        

**deepagents 的适用范围**

- 长时程任务（需要规划 + 文件管理 + 子任务委托）
    
- 复杂的研究型任务（需要多步骤推理）
    
- 不适合：简单的 2-3 步流程（用 LangGraph 原生的 create_react_agent 就够）
    

**对未来的展望**

- Agent 和 Workflow 的边界会越来越模糊
    
- 可能的趋势：
    
    - n8n 等工具集成 LLM 节点，增强决策能力
        
    - Agent 框架提供更强的确定性保证（例如 LangGraph 的 human-in-the-loop）
        
    - 混合架构成为主流
        

**最后一句**

- "ReAct Agent 不会完全替代 Workflow，但它正在重新定义自动化的边界。"
    

---

## 预计字数分布

- 开篇：800
    
- 第一部分：1500
    
- 第二部分：1800
    
- 第三部分：1800
    
- 第四部分：1500
    
- 结尾：600
    
- **总计：8000 字**