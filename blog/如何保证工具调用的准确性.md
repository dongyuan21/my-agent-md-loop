# 如何保证工具调用的准确性：从描述到执行的完整保障体系

> 工具调用（Tool Calling）是AI Agent的核心能力，但准确性一直是痛点。本文从工具描述、参数验证、错误处理、重试机制等多个维度，探讨如何构建一个可靠的工具调用系统。

## 问题：工具调用的准确性挑战

AI编程工具中，工具调用的准确性直接影响用户体验。常见的准确性问题包括：

### 1. 工具选择错误

**场景**：用户想读取文件，但LLM选择了错误的工具

```json
// ❌ 错误：选择了 write_file 而不是 read_file
{
  "tool_call": {
    "name": "write_file",
    "arguments": {
      "path": "config.json",
      "content": ""  // 空内容，意图是读取
    }
  }
}
```

### 2. 参数格式错误

**场景**：工具期望整数，但LLM传了字符串

```json
// ❌ 错误：offset 应该是数字
{
  "tool_call": {
    "name": "read_file",
    "arguments": {
      "path": "hello.java",
      "offset": "0",  // 字符串而不是数字
      "limit": "100"
    }
  }
}
```

### 3. 参数值错误

**场景**：文件路径不存在或格式不正确

```json
// ❌ 错误：路径格式不对
{
  "tool_call": {
    "name": "read_file",
    "arguments": {
      "path": "../hello.java"  // 相对路径可能解析错误
    }
  }
}
```

### 4. 工具调用时机错误

**场景**：在不需要的时候调用了工具，或需要时没有调用

```python
# ❌ 错误：用户只是问"你好"，不需要调用工具
user: "你好"
assistant: [调用 read_file 工具]  # 不应该调用

# ❌ 错误：用户问文件内容，但没有调用工具
user: "config.json 里有什么？"
assistant: "根据我的记忆，config.json 包含..."  # 应该先读取文件
```

---

## 解决方案：多层次的准确性保障

### 层次1：工具描述（Tool Description）

工具描述是LLM选择工具的主要依据。好的描述应该：

#### 1.1 明确功能边界

```python
# ❌ 模糊的描述
@tool
def file_operation(path: str, action: str) -> str:
    """对文件进行操作"""
    pass

# ✅ 清晰的描述
@tool
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取指定文件的内容。
    
    用途：当用户需要查看文件内容、分析代码、检查配置时使用此工具。
    
    不适用于：
    - 修改文件（使用 write_file）
    - 搜索文件（使用 search_files）
    - 列出目录（使用 list_directory）
    """
    pass
```

#### 1.2 提供使用示例

```python
@tool
def search_files(query: str, file_type: str = None) -> list[dict]:
    """在项目中搜索文件。
    
    示例：
    - 搜索Java文件：search_files("User", "java")
    - 搜索所有包含"config"的文件：search_files("config")
    - 查找测试文件：search_files("test", "py")
    
    Args:
        query: 搜索关键词（文件名或内容关键词）
        file_type: 可选的文件扩展名过滤（如 "java", "py"）
    
    Returns:
        匹配的文件列表，每个文件包含 path 和 relevance_score
    """
    pass
```

#### 1.3 明确触发条件

```python
@tool
def read_file(path: str) -> str:
    """读取文件内容。
    
    何时使用：
    - 用户明确提到文件名："查看 hello.java"
    - 用户询问文件内容："config.json 里有什么？"
    - 需要分析代码时："帮我看看这个文件的问题"
    
    何时不使用：
    - 用户只是询问概念："什么是构造函数？"
    - 文件路径不明确时，先使用 search_files 查找
    """
    pass
```

#### 1.4 描述返回格式

```python
@tool
def search_files(query: str) -> list[dict]:
    """搜索文件。
    
    Returns:
        文件列表，格式：
        [
            {
                "path": "src/main/java/User.java",
                "relevance_score": 0.95,
                "snippet": "public class User { ... }"
            }
        ]
    """
    pass
```

---

### 层次2：参数Schema验证（Schema Validation）

#### 什么是Schema？

**Schema（模式/架构）** 在这里指的是**参数的数据结构定义**，它描述了：
- 参数有哪些字段
- 每个字段的类型（字符串、整数、布尔值等）
- 每个字段的约束（最小值、最大值、可选/必需等）
- 每个字段的验证规则（格式、范围等）

**类比理解**：
- 就像数据库表结构定义了每列的数据类型和约束
- 就像API文档定义了请求参数的结构
- 就像JSON Schema定义了JSON数据的格式

**实际例子对比**：

```python
# 方式1：没有Schema（只有函数签名）
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取文件"""
    pass

# 问题：LLM调用时可能传入错误值
read_file(
    path="../../etc/passwd",  # 危险路径，但没有验证
    offset="abc",             # 类型错误，但运行时才报错
    limit=-100                 # 负数，但函数可能不会检查
)

# 方式2：有Schema（Pydantic模型）
class ReadFileParams(BaseModel):
    path: str = Field(..., description="文件路径")
    offset: int = Field(default=0, ge=0, description="起始行号，>= 0")
    limit: int = Field(default=500, ge=1, le=10000, description="读取行数，1-10000")
    
    @validator('path')
    def validate_path(cls, v):
        if '..' in v:
            raise ValueError("路径不安全")
        return v

@tool(args_schema=ReadFileParams)
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取文件"""
    pass

# 优势：在调用函数之前就验证参数
# 1. 类型自动转换："0" → 0
# 2. 范围检查：-100 → 验证失败
# 3. 自定义验证：../../etc/passwd → 验证失败
# 4. 清晰的错误信息：告诉LLM具体哪里错了
```

**为什么需要Schema？**

没有Schema时，LLM可能返回各种格式错误的参数：
```python
# ❌ 没有Schema：LLM可能返回错误格式
{
  "path": "../hello.java",  # 路径不安全
  "offset": "-1",           # 负数，应该是 >= 0
  "limit": "99999"          # 超出范围，应该是 1-10000
}
```

有了Schema后，可以自动验证和修正：
```python
# ✅ 有Schema：自动验证和类型转换
ReadFileParams(
  path="../hello.java",  # Schema验证器会拒绝
  offset="-1",            # 自动转换为整数，但验证失败（< 0）
  limit="99999"          # 自动转换为整数，但验证失败（> 10000）
)
# → 抛出 ValidationError，明确指出哪些参数有问题
```

#### 2.1 Pydantic Schema定义

```python
from pydantic import BaseModel, Field, validator
from typing import Literal

class ReadFileParams(BaseModel):
    """读取文件的参数定义"""
    path: str = Field(
        ...,
        description="文件路径，必须是绝对路径或相对于项目根目录的路径",
        examples=["src/main/java/Hello.java", "/absolute/path/to/file.java"]
    )
    offset: int = Field(
        default=0,
        ge=0,
        description="起始行号，从0开始，必须 >= 0"
    )
    limit: int = Field(
        default=500,
        ge=1,
        le=10000,
        description="读取行数，范围 1-10000"
    )
    
    @validator('path')
    def validate_path(cls, v):
        # 禁止危险路径
        if '..' in v or v.startswith('/'):
            # 标准化处理
            if v.startswith('/'):
                raise ValueError("请使用相对路径，不要使用绝对路径")
            if '..' in v:
                raise ValueError("路径中不能包含 '..'，请使用相对于项目根目录的路径")
        return v

@tool(args_schema=ReadFileParams)
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取文件内容"""
    pass
```

#### 2.2 自动类型转换

```python
# LLM可能返回字符串 "100"，但Schema会自动转换为整数
{
  "tool_call": {
    "name": "read_file",
    "arguments": {
      "path": "hello.java",
      "offset": "0",  # 字符串
      "limit": "100"  # 字符串
    }
  }
}

# Pydantic自动转换
ReadFileParams(offset="0", limit="100")
# → ReadFileParams(offset=0, limit=100)  # 整数
```

#### 2.3 枚举类型约束

```python
class SearchFilesParams(BaseModel):
    query: str
    file_type: Literal["java", "py", "js", "ts", "md"] = Field(
        None,
        description="文件类型过滤，可选值：java, py, js, ts, md"
    )

@tool(args_schema=SearchFilesParams)
def search_files(query: str, file_type: str = None) -> list[dict]:
    """搜索文件"""
    pass
```

---

### 层次3：运行时验证（Runtime Validation）

即使Schema验证通过，运行时仍需要额外检查。

#### 3.1 文件存在性检查

```python
@tool
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取文件内容"""
    import os
    
    # 1. 路径标准化
    normalized_path = os.path.normpath(path)
    
    # 2. 安全检查：防止路径遍历攻击
    if not normalized_path.startswith(project_root):
        raise ValueError(f"路径必须在项目根目录内: {path}")
    
    # 3. 文件存在性检查
    if not os.path.exists(normalized_path):
        # 提供友好的错误信息
        similar_files = find_similar_files(normalized_path)
        error_msg = f"文件不存在: {path}"
        if similar_files:
            error_msg += f"\n可能您想找的是: {', '.join(similar_files[:3])}"
        raise FileNotFoundError(error_msg)
    
    # 4. 文件类型检查
    if not os.path.isfile(normalized_path):
        raise ValueError(f"路径不是文件: {path}")
    
    # 5. 读取文件
    try:
        with open(normalized_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            return ''.join(lines[offset:offset+limit])
    except UnicodeDecodeError:
        raise ValueError(f"文件不是文本格式，无法读取: {path}")
```

#### 3.2 参数合理性检查

```python
@tool
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取文件内容"""
    # 获取文件总行数
    total_lines = count_lines(path)
    
    # 检查offset是否超出范围
    if offset >= total_lines:
        raise ValueError(
            f"起始行号 {offset} 超出文件范围（文件共 {total_lines} 行）"
        )
    
    # 检查limit是否过大
    if limit > 10000:
        raise ValueError(
            f"读取行数 {limit} 过大，最大允许 10000 行。"
            f"建议分批读取或使用 grep 工具搜索特定内容。"
        )
    
    # 实际读取
    return read_lines(path, offset, limit)
```

---

### 层次4：错误处理和友好提示

工具调用失败时，应该提供清晰的错误信息，帮助LLM理解问题并重试。

#### 4.1 结构化错误信息

```python
@tool
def read_file(path: str) -> str:
    """读取文件内容"""
    try:
        # 尝试读取
        return read_file_content(path)
    except FileNotFoundError as e:
        # ❌ 不好的错误信息
        # raise e
        
        # ✅ 好的错误信息：包含上下文和建议
        raise ToolExecutionError(
            message=f"文件不存在: {path}",
            error_type="FileNotFoundError",
            suggestions=[
                "检查文件路径是否正确",
                "使用 search_files 工具搜索文件",
                "使用 list_directory 工具查看目录内容"
            ],
            context={
                "requested_path": path,
                "project_root": project_root,
                "similar_files": find_similar_files(path)
            }
        )
```

#### 4.2 错误信息格式

```python
class ToolExecutionError(Exception):
    """工具执行错误"""
    def __init__(
        self,
        message: str,
        error_type: str,
        suggestions: list[str] = None,
        context: dict = None
    ):
        self.message = message
        self.error_type = error_type
        self.suggestions = suggestions or []
        self.context = context or {}
    
    def to_dict(self) -> dict:
        """转换为字典，便于LLM理解"""
        return {
            "error": True,
            "error_type": self.error_type,
            "message": self.message,
            "suggestions": self.suggestions,
            "context": self.context
        }
```

#### 4.3 LLM接收错误信息

```json
{
  "role": "tool",
  "tool_call_id": "call_xxx",
  "content": "{\"error\": true, \"error_type\": \"FileNotFoundError\", \"message\": \"文件不存在: hello.java\", \"suggestions\": [\"检查文件路径是否正确\", \"使用 search_files 工具搜索文件\"], \"context\": {\"requested_path\": \"hello.java\", \"similar_files\": [\"Hello.java\", \"hello_world.java\"]}}"
}
```

LLM看到这个错误后，可以：
1. 理解问题：文件不存在
2. 获取建议：使用 search_files 搜索
3. 获取上下文：可能有相似文件

---

### 层次5：重试机制（Retry Strategy）

工具调用失败时，应该支持智能重试。

#### 5.1 自动重试策略

```python
class ToolExecutor:
    def __init__(self, max_retries: int = 3):
        self.max_retries = max_retries
    
    def execute_with_retry(
        self,
        tool: Tool,
        arguments: dict,
        context: dict = None
    ) -> Any:
        """执行工具，支持自动重试"""
        last_error = None
        
        for attempt in range(self.max_retries):
            try:
                # 执行工具
                result = tool.invoke(arguments)
                return result
                
            except ToolExecutionError as e:
                last_error = e
                
                # 判断是否应该重试
                if not self._should_retry(e, attempt):
                    break
                
                # 如果是路径问题，尝试修正
                if e.error_type == "FileNotFoundError":
                    corrected_path = self._try_correct_path(
                        e.context.get("requested_path"),
                        e.context.get("similar_files", [])
                    )
                    if corrected_path:
                        arguments["path"] = corrected_path
                        continue
                
                # 等待后重试
                time.sleep(0.5 * (attempt + 1))
        
        # 所有重试都失败，返回错误
        raise last_error
    
    def _should_retry(self, error: ToolExecutionError, attempt: int) -> bool:
        """判断是否应该重试"""
        # 不可重试的错误类型
        non_retryable = ["PermissionDenied", "InvalidArgument"]
        if error.error_type in non_retryable:
            return False
        
        # 超过最大重试次数
        if attempt >= self.max_retries - 1:
            return False
        
        return True
    
    def _try_correct_path(self, path: str, similar_files: list[str]) -> str:
        """尝试修正文件路径"""
        if not similar_files:
            return None
        
        # 选择最相似的文件
        best_match = similar_files[0]
        # 简单的相似度判断：文件名相同但大小写不同
        if best_match.lower() == path.lower():
            return best_match
        
        return None
```

#### 5.2 LLM引导的重试

```python
# 第一次调用失败
{
  "role": "tool",
  "tool_call_id": "call_xxx",
  "content": "{\"error\": true, \"message\": \"文件不存在: hello.java\", \"suggestions\": [\"使用 search_files 工具搜索\"]}"
}

# LLM分析错误，决定使用 search_files
{
  "role": "assistant",
  "tool_calls": [{
    "name": "search_files",
    "arguments": {"query": "hello.java"}
  }]
}

# 搜索成功，找到文件
{
  "role": "tool",
  "tool_call_id": "call_yyy",
  "content": "[{\"path\": \"src/main/java/Hello.java\", \"relevance_score\": 0.95}]"
}

# LLM使用正确的路径重新读取
{
  "role": "assistant",
  "tool_calls": [{
    "name": "read_file",
    "arguments": {"path": "src/main/java/Hello.java"}
  }]
}
```

---

### 层次6：工具选择优化

#### 6.1 工具描述优化

```python
# ❌ 不好的工具描述：太简短
@tool
def read_file(path: str) -> str:
    """读取文件"""
    pass

# ✅ 好的工具描述：详细且明确
@tool
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取指定文件的内容。
    
    功能：读取文本文件的内容，支持指定起始行号和读取行数限制。
    
    使用场景：
    - 用户明确提到文件名："查看 hello.java"
    - 用户询问文件内容："config.json 里有什么？"
    - 需要分析代码时："帮我看看这个文件的问题"
    - 需要查看特定行："读取第10-20行"
    
    不适用于：
    - 修改文件（使用 write_file 工具）
    - 搜索文件（使用 search_files 工具）
    - 列出目录（使用 list_directory 工具）
    - 搜索文件内容（使用 grep 工具）
    
    参数说明：
    - path: 文件路径，相对于项目根目录
    - offset: 起始行号，从0开始，默认0
    - limit: 读取行数，默认500，最大10000
    
    返回：文件内容的字符串
    
    示例：
    - read_file("src/main/java/Hello.java")
    - read_file("config.json", offset=10, limit=20)
    """
    pass
```

#### 6.2 工具分类和优先级

```python
# 工具分类，帮助LLM理解工具之间的关系
TOOL_CATEGORIES = {
    "file_operations": {
        "read": ["read_file"],
        "write": ["write_file", "append_file"],
        "search": ["search_files", "grep"],
        "list": ["list_directory"]
    },
    "code_analysis": {
        "parse": ["parse_code", "extract_functions"],
        "analyze": ["analyze_syntax", "check_errors"]
    }
}

# 在系统提示词中说明工具分类
SYSTEM_PROMPT = f"""
你可以使用以下工具：

文件操作类：
- read_file: 读取文件内容
- write_file: 写入文件
- search_files: 搜索文件
- list_directory: 列出目录

代码分析类：
- parse_code: 解析代码结构
- analyze_syntax: 分析语法

选择工具时，优先考虑：
1. 文件操作类：当需要访问文件系统时
2. 代码分析类：当需要分析代码结构时
"""
```

#### 6.3 工具调用示例学习

```python
# 在系统提示词中提供工具调用示例
TOOL_USAGE_EXAMPLES = """
工具调用示例：

场景1：用户问"hello.java 里有什么？"
→ 调用 read_file("hello.java")

场景2：用户问"找到所有包含 User 的文件"
→ 调用 search_files("User")

场景3：用户问"修改 config.json，添加新配置"
→ 先调用 read_file("config.json") 读取现有内容
→ 再调用 write_file("config.json", new_content) 写入

场景4：用户问"列出 src 目录下的文件"
→ 调用 list_directory("src")
"""
```

---

### 层次7：监控和反馈

#### 7.1 工具调用日志

```python
class ToolCallLogger:
    def log_tool_call(
        self,
        tool_name: str,
        arguments: dict,
        result: Any,
        execution_time: float,
        success: bool,
        error: Exception = None
    ):
        """记录工具调用"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "tool_name": tool_name,
            "arguments": arguments,
            "success": success,
            "execution_time": execution_time,
            "error": str(error) if error else None
        }
        
        # 记录到日志系统
        logger.info("Tool call", extra=log_entry)
        
        # 如果失败，发送告警
        if not success:
            self._alert_on_failure(tool_name, error)
```

#### 7.2 工具调用统计

```python
class ToolCallAnalytics:
    def __init__(self):
        self.stats = {
            "total_calls": 0,
            "success_calls": 0,
            "failed_calls": 0,
            "tool_usage": {},  # {tool_name: count}
            "error_types": {},  # {error_type: count}
            "avg_execution_time": {}  # {tool_name: avg_time}
        }
    
    def record_call(
        self,
        tool_name: str,
        success: bool,
        execution_time: float,
        error_type: str = None
    ):
        """记录工具调用统计"""
        self.stats["total_calls"] += 1
        
        if success:
            self.stats["success_calls"] += 1
        else:
            self.stats["failed_calls"] += 1
            if error_type:
                self.stats["error_types"][error_type] = \
                    self.stats["error_types"].get(error_type, 0) + 1
        
        # 更新工具使用统计
        self.stats["tool_usage"][tool_name] = \
            self.stats["tool_usage"].get(tool_name, 0) + 1
        
        # 更新平均执行时间
        if tool_name not in self.stats["avg_execution_time"]:
            self.stats["avg_execution_time"][tool_name] = []
        self.stats["avg_execution_time"][tool_name].append(execution_time)
    
    def get_accuracy_rate(self) -> float:
        """获取准确率"""
        if self.stats["total_calls"] == 0:
            return 0.0
        return self.stats["success_calls"] / self.stats["total_calls"]
    
    def get_problematic_tools(self) -> list[tuple]:
        """获取问题最多的工具"""
        error_rates = {}
        for tool_name, total in self.stats["tool_usage"].items():
            # 计算每个工具的错误率（简化版）
            # 实际应该更详细地追踪每个工具的成功/失败
            pass
        return sorted(error_rates.items(), key=lambda x: x[1], reverse=True)
```

---

## 最佳实践总结

### 1. 工具描述要详细

- ✅ 明确功能边界
- ✅ 提供使用示例
- ✅ 说明触发条件
- ✅ 描述返回格式

### 2. 参数验证要严格

- ✅ 使用强类型Schema（Pydantic）
- ✅ 添加字段验证器
- ✅ 提供默认值和范围限制
- ✅ 自动类型转换

### 3. 运行时检查要全面

- ✅ 文件存在性检查
- ✅ 路径安全性检查
- ✅ 参数合理性检查
- ✅ 权限检查

### 4. 错误信息要友好

- ✅ 清晰的错误消息
- ✅ 提供修复建议
- ✅ 包含上下文信息
- ✅ 结构化错误格式

### 5. 重试机制要智能

- ✅ 区分可重试和不可重试的错误
- ✅ 自动路径修正
- ✅ LLM引导的重试
- ✅ 限制重试次数

### 6. 工具选择要优化

- ✅ 详细的工具描述
- ✅ 工具分类和优先级
- ✅ 提供使用示例
- ✅ 工具之间的关系说明

### 7. 监控和反馈要持续

- ✅ 记录所有工具调用
- ✅ 统计成功率和错误类型
- ✅ 识别问题工具
- ✅ 持续优化

---

## 实际案例：read_file 工具的完整实现

```python
from pydantic import BaseModel, Field, validator
from typing import Optional
import os
from pathlib import Path

class ReadFileParams(BaseModel):
    """读取文件的参数定义"""
    path: str = Field(
        ...,
        description="文件路径，相对于项目根目录",
        examples=["src/main/java/Hello.java", "config.json"]
    )
    offset: int = Field(
        default=0,
        ge=0,
        description="起始行号，从0开始"
    )
    limit: int = Field(
        default=500,
        ge=1,
        le=10000,
        description="读取行数，范围 1-10000"
    )
    
    @validator('path')
    def validate_path(cls, v):
        # 安全检查
        if '..' in v:
            raise ValueError("路径中不能包含 '..'")
        if v.startswith('/'):
            raise ValueError("请使用相对路径")
        return v

class ToolExecutionError(Exception):
    """工具执行错误"""
    def __init__(self, message: str, error_type: str, suggestions: list[str] = None):
        self.message = message
        self.error_type = error_type
        self.suggestions = suggestions or []
    
    def to_dict(self) -> dict:
        return {
            "error": True,
            "error_type": self.error_type,
            "message": self.message,
            "suggestions": self.suggestions
        }

@tool(args_schema=ReadFileParams)
def read_file(path: str, offset: int = 0, limit: int = 500) -> str:
    """读取指定文件的内容。
    
    功能：读取文本文件的内容，支持指定起始行号和读取行数限制。
    
    使用场景：
    - 用户明确提到文件名："查看 hello.java"
    - 用户询问文件内容："config.json 里有什么？"
    - 需要分析代码时："帮我看看这个文件的问题"
    
    不适用于：
    - 修改文件（使用 write_file 工具）
    - 搜索文件（使用 search_files 工具）
    - 搜索文件内容（使用 grep 工具）
    
    参数说明：
    - path: 文件路径，相对于项目根目录
    - offset: 起始行号，从0开始，默认0
    - limit: 读取行数，默认500，最大10000
    
    返回：文件内容的字符串
    
    示例：
    - read_file("src/main/java/Hello.java")
    - read_file("config.json", offset=10, limit=20)
    """
    try:
        # 1. 路径标准化
        normalized_path = Path(path).resolve()
        project_root = Path(os.getenv("PROJECT_ROOT", ".")).resolve()
        
        # 2. 安全检查
        try:
            normalized_path.relative_to(project_root)
        except ValueError:
            raise ToolExecutionError(
                message=f"路径必须在项目根目录内: {path}",
                error_type="SecurityError",
                suggestions=["检查路径是否正确", "使用相对路径"]
            )
        
        # 3. 文件存在性检查
        if not normalized_path.exists():
            # 尝试查找相似文件
            similar_files = find_similar_files(path, project_root)
            suggestions = ["检查文件路径是否正确"]
            if similar_files:
                suggestions.append(f"可能您想找的是: {', '.join(similar_files[:3])}")
            suggestions.append("使用 search_files 工具搜索文件")
            
            raise ToolExecutionError(
                message=f"文件不存在: {path}",
                error_type="FileNotFoundError",
                suggestions=suggestions
            )
        
        # 4. 文件类型检查
        if not normalized_path.is_file():
            raise ToolExecutionError(
                message=f"路径不是文件: {path}",
                error_type="InvalidPathError",
                suggestions=["检查路径是否正确", "使用 list_directory 查看目录内容"]
            )
        
        # 5. 读取文件
        try:
            with open(normalized_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                total_lines = len(lines)
                
                # 检查offset
                if offset >= total_lines:
                    raise ToolExecutionError(
                        message=f"起始行号 {offset} 超出文件范围（文件共 {total_lines} 行）",
                        error_type="InvalidArgumentError",
                        suggestions=[f"文件共 {total_lines} 行，请使用 0-{total_lines-1} 之间的行号"]
                    )
                
                # 读取指定范围
                selected_lines = lines[offset:offset+limit]
                return ''.join(selected_lines)
                
        except UnicodeDecodeError:
            raise ToolExecutionError(
                message=f"文件不是文本格式，无法读取: {path}",
                error_type="UnsupportedFileTypeError",
                suggestions=["此工具只能读取文本文件", "二进制文件需要使用其他工具"]
            )
            
    except ToolExecutionError:
        raise
    except Exception as e:
        # 未知错误
        raise ToolExecutionError(
            message=f"读取文件时发生错误: {str(e)}",
            error_type="UnknownError",
            suggestions=["检查文件权限", "联系技术支持"]
        )

def find_similar_files(target_path: str, project_root: Path, max_results: int = 3) -> list[str]:
    """查找相似的文件名"""
    target_name = Path(target_path).name.lower()
    similar = []
    
    for file_path in project_root.rglob("*"):
        if file_path.is_file():
            file_name = file_path.name.lower()
            # 简单的相似度判断
            if target_name in file_name or file_name in target_name:
                similar.append(str(file_path.relative_to(project_root)))
                if len(similar) >= max_results:
                    break
    
    return similar
```

---

## 总结

保证工具调用的准确性需要多层次的保障：

1. **描述层**：清晰详细的工具描述，帮助LLM正确选择工具
2. **Schema层**：强类型参数定义，自动验证和类型转换
3. **运行时层**：全面的安全检查、存在性检查、合理性检查
4. **错误处理层**：友好的错误信息，包含修复建议
5. **重试层**：智能的重试机制，自动修正常见错误
6. **选择优化层**：工具分类、优先级、使用示例
7. **监控层**：持续监控和反馈，识别问题并优化

只有在这7个层次都做到位，才能构建一个可靠的工具调用系统。

---

## 延伸阅读

- [OpenAI Function Calling Best Practices](https://platform.openai.com/docs/guides/function-calling)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [LangChain Tool Calling](https://python.langchain.com/docs/modules/tools/)
- [ReAct: Synergizing Reasoning and Acting](https://arxiv.org/abs/2210.03629)
